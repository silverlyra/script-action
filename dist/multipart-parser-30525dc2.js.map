{"version":3,"file":"multipart-parser-30525dc2.js","sources":["../node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"names":["s","S","f","F","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","boundary","ui8a","i","data","length_","previousIndex","lookbehind","boundaryChars","index","state","flags","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","dataCallback","markSymbol","_lookbehind","_fileName","headerValue","m","match","filename","code","toFormData","Body","ct","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","FormData","onPartData","decoder","appendToFile","appendFileToFormData","file","File","appendEntryToFormData","chunk"],"mappings":"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","x_google_ignoreList":[0]}